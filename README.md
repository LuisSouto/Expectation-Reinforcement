# Expectation-Reinforcement
Implementation in C++ of the Expectation Reinforcement algorithm.

The simulated data was generated by the authors, while the empirical Canadian data was obtained from Prof. E. W. Frees, to whom one may be referred to get access to said data. Therefore, we provide the synthetic data only, and not the empirical one. The empirical data is referred to as UOFM in the scripts. For a description of how the original empirical data has been preprocessed, see https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3593391, beginning of section 5.2.

The synthetic data consists of 10000 observations of bivariate left-truncated and right-censored samples. Each observation contains the two (possibly censored) observed values (X and Y), the two truncation values (TX and TY) , the two censoring indicators delta_X and delta_Y (we use the convention: 1 for uncensored and 0 for censored) and finally the difference between TY and TX, TY-TX. This makes a total of 7 variables per observation. Clearly, only the first 6 variables are independent.

The distributions of each variable, as well as the specific censoring and truncation mechanisms, can be found in the script generate_ltrc_data.py. Due to differences in the pseudo-random sequences, running the aforementioned script may yield different datasets than the one we provide, but because the underlying distributions are the same, the statistical properties should also be the same, up to numerical errors.

In order to compile the code one needs the g++ compiler, or change the makefile to allow a different compiler.

Inside the C++ folder, run the makefile to compile the ER code. Then, execute sh build.sh on a linux terminal (or the corresponding syntax in another operating system) and, after successful compilation, run ./BRUP_ER to execute the code.

The results computed by BRUP_ER.cpp will go to the results folder (this folder may need to be created beforehand to run the code), which can then be analyzed using the analyze_results.py Python script.
